using System;
using System.Collections.Generic;
using System.Linq;
using Lunra.Core;
using Lunra.Hothouse.Ai;
using Lunra.Hothouse.Models;
using Lunra.Satchel;
using Lunra.StyxMvp.Services;
using UnityEngine;

namespace Lunra.Hothouse.Services
{
	public class LogisticsService : BindableService<GameModel>
	{
		struct ItemCache
		{
			public Item Item;
			public int Priority;
			public bool IsReservation;
			public IInventoryModel Parent;
		}

		struct ContainerConnection : IEquatable<ContainerConnection>
		{
			public static ContainerConnection Between(long primary, long secondary) => new ContainerConnection(primary, secondary);
			
			public long Primary { get; }
			public long Secondary { get; }

			public ContainerConnection(
				long primary,
				long secondary
			)
			{
				Primary = primary;
				Secondary = secondary;
			}
			
			public override bool Equals(object obj) => obj is ContainerConnection connection && Equals(connection);

			public bool Equals(ContainerConnection other)
			{
				if (Primary == other.Primary) return Secondary == other.Secondary;
				return Primary == other.Secondary && Secondary == other.Primary;
			}

			// This code was autogenerated by Rider...
			public override int GetHashCode()
			{
				unchecked
				{
					return (Primary.GetHashCode() * 397) ^ Secondary.GetHashCode();
				}
			}

			public static bool operator ==(ContainerConnection left, ContainerConnection right) => left.Equals(right);

			public static bool operator !=(ContainerConnection left, ContainerConnection right) => !left.Equals(right);
		}

		DateTime lastNavigationCache;
		Dictionary<ContainerConnection, bool> navigationCache = new Dictionary<ContainerConnection, bool>();
		
		public LogisticsService(GameModel model) : base(model)
		{
			
		}
		
		protected override void Bind()
		{
			Model.SimulationUpdate += OnGameSimulationUpdate;
		}

		protected override void UnBind()
		{
			Model.SimulationUpdate -= OnGameSimulationUpdate;
		}

		bool hasBruk = false;
		
		#region GameModel Events
		void OnGameSimulationUpdate()
		{
			if (!hasBruk)
			{
				// Debug.Break();
				hasBruk = true;
				return;
			}

			try
			{
				switch (Model.NavigationMesh.CalculationState.Value)
				{
					case NavigationMeshModel.CalculationStates.NotInitialized:
					case NavigationMeshModel.CalculationStates.Queued:
					case NavigationMeshModel.CalculationStates.Calculating:
						return;
					case NavigationMeshModel.CalculationStates.Completed:
						break;
					default:
						Debug.LogError($"Unrecognized Calculation State: {Model.NavigationMesh.CalculationState.Value}");
						return;
				}

				if (lastNavigationCache < Model.NavigationMesh.LastUpdated.Value)
				{
					lastNavigationCache = Model.NavigationMesh.LastUpdated.Value;
					navigationCache.Clear();
				}
				
				// Do I need to calculate here??? Probably should have inventories do it when needed...
				// It becomes really hard to know what needs to be calculated when if we don't just calculate everything here
				foreach (var inventory in Model.Query.All<IInventoryModel>())
				{
					inventory.Inventory.Calculate();
				}

				var dwellers = new Dictionary<string, DwellerModel>();

				foreach (var dweller in Model.Dwellers.AllActive)
				{
					if (dweller.InventoryPromises.All.None()) dwellers.Add(dweller.Id.Value, dweller);
				}

				if (dwellers.None()) return;

				var reservationInputs = new Dictionary<long, ItemCache>();
				var itemOutputs = new Dictionary<long, ItemCache>();
				var capacityPoolIdsToCapacities = new Dictionary<long, List<long>>();

				var capacitiesWithUnPromisedReservations = new HashSet<long>(); 
				
				foreach (var item in Model.Items.All())
				{
					if (!item.IsValid) continue;

					var cache = new ItemCache { Item = item };

					long capacityPoolId;
					
					if (item.TryGet(Items.Keys.Reservation.LogisticState, out var logisticState))
					{
						cache.IsReservation = true;
						capacityPoolId = item[Items.Keys.Reservation.CapacityPoolId];
						if (item[Items.Keys.Reservation.TransferId] == IdCounter.UndefinedId) capacitiesWithUnPromisedReservations.Add(item[Items.Keys.Reservation.CapacityId]);
					}
					else if (item.TryGet(Items.Keys.Resource.LogisticState, out logisticState))
					{
						capacityPoolId = item[Items.Keys.Resource.CapacityPoolId];
					}
					else if (item.TryGet(Items.Keys.Capacity.CapacityPoolId, out capacityPoolId))
					{
						if (!capacityPoolIdsToCapacities.TryGetValue(capacityPoolId, out var capacities))
						{
							capacities = new List<long>();
							capacityPoolIdsToCapacities.Add(capacityPoolId, capacities);
						}
						
						capacities.Add(item.Id);
						
						continue;
					}
					else continue;

					if (Model.Items.TryGet(capacityPoolId, out var capacityPool))
					{
						cache.Priority = capacityPool[Items.Keys.CapacityPool.Priority];
					}
					else
					{
						Debug.LogError($"Cannot find capacity pool [ {capacityPoolId} ]");
						continue;
					}

					if (Model.Query.TryFindFirst(m => m.Inventory.Container.Id == item.ContainerId, out cache.Parent))
					{
						if (cache.IsReservation)
						{
							if (logisticState == Items.Values.Reservation.LogisticStates.Input) reservationInputs.Add(item.Id, cache);
							else if (logisticState == Items.Values.Reservation.LogisticStates.Output) itemOutputs.Add(item.Id, cache);
							else Debug.LogError($"Unrecognized {Items.Keys.Reservation.LogisticState} on reservation {item}");
						}
						else
						{
							// Don't want to include already reserved items...
							if (item[Items.Keys.Resource.LogisticState] != Items.Values.Resource.LogisticStates.None) continue;
							// Any items that are surplus will already have output reservations, so we don't need to add them again...
							if (capacityPool[Items.Keys.CapacityPool.CountTarget] < capacityPool[Items.Keys.CapacityPool.CountCurrent]) continue;
						
							// If we get here we know it's a resource that is part of a filled or nearly filled capacity...
							itemOutputs.Add(item.Id, cache);
						}
					}
					else Debug.LogError($"Cannot find parent of container {item.ContainerId} for item {item}");
				}

				var reservationInputsSorted = reservationInputs.Values
					.OrderBy(r => r.Priority)
					.ToList();

				while (dwellers.Any() && reservationInputsSorted.Any())
				{
					var reservationInput = reservationInputsSorted[0];
					reservationInputsSorted.RemoveAt(0);

					if (!reservationInput.Parent.Inventory.Capacities.TryGetValue(reservationInput.Item[Items.Keys.Reservation.CapacityId], out var filter))
					{
						Debug.LogError($"Cannot find filter for reservation {reservationInput.Item}");
						continue;
					}

					var reservationInputRemaining = reservationInput.Item.InstanceCount;

					var itemOutputsSorted = itemOutputs.Values
						.Where(i => reservationInput.Priority < i.Priority)
						.OrderBy(i => i.Priority)
						.ThenBy(i => i.Parent.DistanceTo(reservationInput.Parent))
						.ToList();

					while (0 < reservationInputRemaining && itemOutputsSorted.Any() && dwellers.Any())
					{
						var itemOutput = itemOutputsSorted[0];
						itemOutputsSorted.RemoveAt(0);

						if (reservationInput.Item.ContainerId == itemOutput.Item.ContainerId)
						{
							if (!itemOutput.IsReservation && itemOutput.Item[Items.Keys.Resource.CapacityPoolId] == reservationInput.Item[Items.Keys.Reservation.CapacityPoolId])
							{
								// This item is already fulfilling some part of this input's pool...
								continue;
							}
						}
						
						var itemOutputRemaining = itemOutput.Item.InstanceCount;

						var dwellersSorted = dwellers.Values
							.OrderBy(d => d.DistanceTo(itemOutput.Parent))
							.ToList();

						while (0 < reservationInputRemaining && 0 < itemOutputRemaining && dwellersSorted.Any())
						{
							var dweller = dwellersSorted[0];
							dwellersSorted.RemoveAt(0);

							if (!IsNavigable(dweller, reservationInput, itemOutput)) continue;

							bool validateTransfer(Item item)
							{
								if (filter.Validate(item))
								{
									var output = new InventoryPromiseComponent.TransferInfo
									{
										Container = itemOutput.Parent.Inventory.Container,
									};

									if (itemOutput.IsReservation)
									{
										output.CapacityPool = Model.Items.First(itemOutput.Item[Items.Keys.Reservation.CapacityPoolId]);
										output.Capacity = Model.Items.First(itemOutput.Item[Items.Keys.Reservation.CapacityId]);
										output.Reservation = itemOutput.Item;
									}
									else
									{
										output.CapacityPool = Model.Items.First(itemOutput.Item[Items.Keys.Resource.CapacityPoolId]);
										if (capacityPoolIdsToCapacities.TryGetValue(output.CapacityPool.Id, out var capacityFilterIds))
										{
											var capacityId = IdCounter.UndefinedId;
											foreach (var capacityFilterId in capacityFilterIds)
											{
												if (itemOutput.Parent.Inventory.Capacities.TryGetValue(capacityFilterId, out var capacityFilter))
												{
													if (capacityFilter.Validate(item))
													{
														capacityId = capacityFilterId;
														break;
													}
												}
												else Debug.LogError($"Cannot find capacity filter {capacityFilterId} in {itemOutput.Parent.Inventory}");
											}

											if (capacityId == IdCounter.UndefinedId)
											{
												Debug.LogError($"Cannot find capacity for {item}");
												return false;
											}

											output.Capacity = Model.Items.First(capacityId);
										}
										else
										{
											Debug.LogError($"Cannot find list of capacities for capacity pool {output.CapacityPool}");
											return false;
										}
									}
									
									var input = new InventoryPromiseComponent.TransferInfo
									{
										Container = reservationInput.Parent.Inventory.Container,
										Capacity = Model.Items.First(reservationInput.Item[Items.Keys.Reservation.CapacityId]),

										// This capacity pool is required.
										CapacityPool = Model.Items.First(reservationInput.Item[Items.Keys.Reservation.CapacityPoolId]),

										Reservation = reservationInput.Item,
									};
									
									reservationInputRemaining--;
									itemOutputRemaining--;

									var isReservationInputSatisfied = dweller.InventoryPromises.Transfer(
										item,
										output,
										input
									);

									dwellers.Remove(dweller.Id.Value);

									if (isReservationInputSatisfied) return true;
								}

								return false;
							}

							if (itemOutput.IsReservation)
							{
								var items = itemOutput.Parent.Inventory.Container
									.All(i => i[Items.Keys.Resource.CapacityPoolId] == itemOutput.Item[Items.Keys.Reservation.CapacityPoolId])
									.ToList();

								foreach (var (item, _) in items)
								{
									if (validateTransfer(item)) break;
								}
							}
							else validateTransfer(itemOutput.Item);
						}
					}
				}
			}
			catch (Exception e) { Debug.LogException(e); }
		}

		bool IsNavigable(
			DwellerModel dweller,
			ItemCache input,
			ItemCache output
		)
		{
			var dwellerToInputConnection = ContainerConnection.Between(dweller.Inventory.Container.Id, input.Parent.Inventory.Container.Id);
			
			if (!navigationCache.TryGetValue(dwellerToInputConnection, out var isNavigableToInput))
			{
				if (Navigation.TryQuery(input.Parent, out var queryInput))
				{
					isNavigableToInput = NavigationUtility.CalculateNearest(
						dweller.Transform.Position.Value,
						out _,
						queryInput
					);
				}
				else Debug.LogError($"Unable to query {input.Parent}");
								
				navigationCache.Add(dwellerToInputConnection, isNavigableToInput);
			}

			if (!isNavigableToInput) return false;

			var dwellerToOutputConnection = ContainerConnection.Between(dweller.Inventory.Container.Id, output.Parent.Inventory.Container.Id);
			
			if (!navigationCache.TryGetValue(dwellerToOutputConnection, out var isNavigableToOutput))
			{
				if (Navigation.TryQuery(output.Parent, out var queryOutput))
				{
					isNavigableToOutput = NavigationUtility.CalculateNearest(
						dweller.Transform.Position.Value,
						out _,
						queryOutput
					);
				}
				else Debug.LogError($"Unable to query {output.Parent}");
								
				navigationCache.Add(dwellerToOutputConnection, isNavigableToOutput);
			}

			return isNavigableToOutput;
		}
		#endregion
	}
}