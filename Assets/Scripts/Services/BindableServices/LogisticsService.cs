using System;
using System.Collections.Generic;
using System.Linq;
using Lunra.Core;
using Lunra.Hothouse.Ai;
using Lunra.Hothouse.Models;
using Lunra.Satchel;
using Lunra.StyxMvp.Services;
using UnityEngine;

namespace Lunra.Hothouse.Services
{
	public class LogisticsService : BindableService<GameModel>
	{
		struct ItemCache
		{
			public Item Item;
			public int Priority;
			public bool IsReservation;
			public IInventoryModel Parent;
		}

		struct ContainerConnection : IEquatable<ContainerConnection>
		{
			public static ContainerConnection Between(long primary, long secondary) => new ContainerConnection(primary, secondary);
			
			public long Primary { get; }
			public long Secondary { get; }

			public ContainerConnection(
				long primary,
				long secondary
			)
			{
				Primary = primary;
				Secondary = secondary;
			}
			
			public override bool Equals(object obj) => obj is ContainerConnection connection && Equals(connection);

			public bool Equals(ContainerConnection other)
			{
				if (Primary == other.Primary) return Secondary == other.Secondary;
				return Primary == other.Secondary && Secondary == other.Primary;
			}

			// This code was autogenerated by Rider...
			public override int GetHashCode()
			{
				unchecked
				{
					return (Primary.GetHashCode() * 397) ^ Secondary.GetHashCode();
				}
			}

			public static bool operator ==(ContainerConnection left, ContainerConnection right) => left.Equals(right);

			public static bool operator !=(ContainerConnection left, ContainerConnection right) => !left.Equals(right);
		}

		DateTime lastNavigationCache;
		Dictionary<ContainerConnection, bool> navigationCache = new Dictionary<ContainerConnection, bool>();
		
		public LogisticsService(GameModel model) : base(model)
		{
			
		}
		
		protected override void Bind()
		{
			Model.SimulationUpdate += OnGameSimulationUpdate;
		}

		protected override void UnBind()
		{
			Model.SimulationUpdate -= OnGameSimulationUpdate;
		}

		bool hasBruk = false;
		
		#region GameModel Events
		void OnGameSimulationUpdate()
		{
			if (!hasBruk)
			{
				// Debug.Break();
				hasBruk = true;
				return;
			}

			try
			{
				switch (Model.NavigationMesh.CalculationState.Value)
				{
					case NavigationMeshModel.CalculationStates.NotInitialized:
					case NavigationMeshModel.CalculationStates.Queued:
					case NavigationMeshModel.CalculationStates.Calculating:
						return;
					case NavigationMeshModel.CalculationStates.Completed:
						break;
					default:
						Debug.LogError($"Unrecognized Calculation State: {Model.NavigationMesh.CalculationState.Value}");
						return;
				}

				if (lastNavigationCache < Model.NavigationMesh.LastUpdated.Value)
				{
					lastNavigationCache = Model.NavigationMesh.LastUpdated.Value;
					navigationCache.Clear();
				}
				
				// Do I need to calculate here??? Probably should have inventories do it when needed...
				// It becomes really hard to know what needs to be calculated when if we don't just calculate everything here
				foreach (var inventory in Model.Query.All<IInventoryModel>())
				{
					inventory.Inventory.Calculate();
				}

				var dwellers = new Dictionary<string, DwellerModel>();

				foreach (var dweller in Model.Dwellers.AllActive)
				{
					if (dweller.InventoryPromises.All.None()) dwellers.Add(dweller.Id.Value, dweller);
				}

				if (dwellers.None()) return;

				var reservationInputs = new Dictionary<long, ItemCache>();
				var itemOutputs = new Dictionary<long, ItemCache>();

				var capacityPoolsWithReservations = new HashSet<long>(); 
				var itemsToCapacityPoolReservationChecks  = new Dictionary<long, long>();
				
				foreach (var item in Model.Items.All())
				{
					if (!item.IsValid) continue;

					var cache = new ItemCache { Item = item };

					long capacityPoolId;
					
					if (item.TryGet(Items.Keys.Reservation.LogisticState, out var logisticState))
					{
						cache.IsReservation = true;
						capacityPoolId = item[Items.Keys.Reservation.CapacityPoolId];
						capacityPoolsWithReservations.Add(capacityPoolId);
					}
					else if (item.TryGet(Items.Keys.Resource.LogisticState, out logisticState))
					{
						capacityPoolId = item[Items.Keys.Resource.CapacityPoolId];
					}
					else continue;

					if (Model.Items.TryGet(capacityPoolId, out var capacityPool))
					{
						cache.Priority = capacityPool[Items.Keys.CapacityPool.Priority];
					}
					else
					{
						Debug.LogError($"Cannot find capacity pool [ {capacityPoolId} ]");
						continue;
					}

					if (Model.Query.TryFindFirst(m => m.Inventory.Container.Id == item.ContainerId, out cache.Parent))
					{
						if (cache.IsReservation)
						{
							if (logisticState == Items.Values.Reservation.LogisticStates.Input) reservationInputs.Add(item.Id, cache);
							else if (logisticState == Items.Values.Reservation.LogisticStates.Output) itemOutputs.Add(item.Id, cache);
							else Debug.LogError($"Unrecognized {Items.Keys.Reservation.LogisticState} on reservation {item}");
							continue;	
						}
						// Don't want to include already reserved items...
						if (item[Items.Keys.Resource.LogisticState] != Items.Values.Resource.LogisticStates.None) continue;
						// Any items that are surplus will already have output reservations, so we don't need to add them again...
						if (capacityPool[Items.Keys.CapacityPool.CountTarget] < capacityPool[Items.Keys.CapacityPool.CountCurrent]) continue;
						
						// If we get here we know it's a resource that is part of a filled or nearly filled capacity...
						itemsToCapacityPoolReservationChecks.Add(item.Id, capacityPoolId);
						itemOutputs.Add(item.Id, cache);
					}
					else Debug.LogError($"Cannot find parent of container {item.ContainerId} for item {item}");
				}

				var deb = string.Empty;
				
				foreach (var item in itemOutputs.Values.OrderBy(i => i.IsReservation))
				{
					deb += $"\n{item.Item.ToString().WrapColor(item.IsReservation ? "red" : "green")}";
				}
				
				Debug.Log(deb);
				
				// foreach (var item in Model.Items.All(i => i[Items.Keys.Shared.Type] == Items.Values.Shared.Types.Reservation))
				// {
				// 	if (item.NoInstances) continue;
				//
				// 	var logisticState = item[Items.Keys.Reservation.LogisticState];
				//
				// 	var cache = new ItemCache
				// 	{
				// 		Item = item
				// 	};
				//
				// 	var capacityPoolId = item[Items.Keys.Reservation.CapacityPoolId];
				//
				// 	if (!capacityPoolPriorities.TryGetValue(capacityPoolId, out cache.Priority))
				// 	{
				// 		if (Model.Items.TryGet(capacityPoolId, out var capacityPool))
				// 		{
				// 			cache.Priority = capacityPool[Items.Keys.CapacityPool.Priority];
				// 		}
				// 		else Debug.LogError($"Cannot find capacity pool [ {capacityPoolId} ]");
				//
				// 		capacityPoolPriorities[capacityPoolId] = cache.Priority;
				// 	}
				//
				// 	if (Model.Query.TryFindFirst(m => m.Inventory.Container.Id == item.ContainerId, out cache.Parent))
				// 	{
				// 		if (logisticState == Items.Values.Reservation.LogisticStates.Input) reservationInputs.Add(item.Id, cache);
				// 		else if (logisticState == Items.Values.Reservation.LogisticStates.Output) reservationOutputs.Add(item.Id, cache);
				// 		else Debug.LogError($"Unrecognized {Items.Keys.Reservation.LogisticState} on reservation {item}");
				// 	}
				// 	else Debug.LogError($"Cannot find parent of container {item.ContainerId} for item {item}");
				// }

				var reservationInputsSorted = reservationInputs.Values
					.OrderBy(r => r.Priority)
					.ToList();

				while (dwellers.Any() && reservationInputsSorted.Any())
				{
					var reservationInput = reservationInputsSorted[0];
					reservationInputsSorted.RemoveAt(0);

					if (!reservationInput.Parent.Inventory.Capacities.TryGetValue(reservationInput.Item[Items.Keys.Reservation.CapacityId], out var filter))
					{
						Debug.LogError($"Cannot find filter for reservation {reservationInput.Item}");
						continue;
					}

					var reservationInputRemaining = reservationInput.Item.InstanceCount;

					var itemOutputsSorted = itemOutputs.Values
						.Where(i => reservationInput.IsReservation || reservationInput.Priority < i.Priority)
						.OrderBy(i => i.Priority)
						.ThenBy(i => i.Parent.DistanceTo(reservationInput.Parent))
						.ToList();

					while (0 < reservationInputRemaining && itemOutputsSorted.Any() && dwellers.Any())
					{
						var itemOutput = itemOutputsSorted[0];
						itemOutputsSorted.RemoveAt(0);

						var itemOutputRemaining = itemOutput.Item.InstanceCount;

						var dwellersSorted = dwellers.Values
							.OrderBy(d => d.DistanceTo(itemOutput.Parent))
							.ToList();

						while (0 < reservationInputRemaining && 0 < itemOutputRemaining && dwellersSorted.Any())
						{
							var dweller = dwellersSorted[0];
							dwellersSorted.RemoveAt(0);

							if (!IsNavigable(dweller, reservationInput, itemOutput)) continue;

							if (itemOutput.IsReservation)
							{
								var items = itemOutput.Parent.Inventory.Container
									.All(i => i[Items.Keys.Resource.CapacityPoolId] == itemOutput.Item[Items.Keys.Reservation.CapacityPoolId])
									.ToList();

								foreach (var (item, _) in items)
								{
									if (filter.Validate(item))
									{
										reservationInputRemaining--;
										itemOutputRemaining--;

										var output = new InventoryPromiseComponent.TransferInfo
										{
											Container = itemOutput.Parent.Inventory.Container,
											Capacity = Model.Items.First(itemOutput.Item[Items.Keys.Reservation.CapacityId]),

											// It's okay if the source doesn't have a capacity pool.
											CapacityPool = Model.Items.FirstOrDefault(itemOutput.Item[Items.Keys.Reservation.CapacityPoolId]),

											Reservation = itemOutput.Item
										};

										var input = new InventoryPromiseComponent.TransferInfo
										{
											Container = reservationInput.Parent.Inventory.Container,
											Capacity = Model.Items.First(reservationInput.Item[Items.Keys.Reservation.CapacityId]),

											// This capacity pool is required.
											CapacityPool = Model.Items.First(reservationInput.Item[Items.Keys.Reservation.CapacityPoolId]),

											Reservation = reservationInput.Item,
										};

										var isReservationInputSatisfied = dweller.InventoryPromises.Transfer(
											item,
											output,
											input
										);

										dwellers.Remove(dweller.Id.Value);

										if (isReservationInputSatisfied) break;
									}
								}
							}
							else
							{
								
							}
						}
					}
				}
			}
			catch (Exception e) { Debug.LogException(e); }
		}

		bool IsNavigable(
			DwellerModel dweller,
			ItemCache input,
			ItemCache output
		)
		{
			var dwellerToInputConnection = ContainerConnection.Between(dweller.Inventory.Container.Id, input.Parent.Inventory.Container.Id);
			
			if (!navigationCache.TryGetValue(dwellerToInputConnection, out var isNavigableToInput))
			{
				if (Navigation.TryQuery(input.Parent, out var queryInput))
				{
					isNavigableToInput = NavigationUtility.CalculateNearest(
						dweller.Transform.Position.Value,
						out _,
						queryInput
					);
				}
				else Debug.LogError($"Unable to query {input.Parent}");
								
				navigationCache.Add(dwellerToInputConnection, isNavigableToInput);
			}

			if (!isNavigableToInput) return false;

			var dwellerToOutputConnection = ContainerConnection.Between(dweller.Inventory.Container.Id, output.Parent.Inventory.Container.Id);
			
			if (!navigationCache.TryGetValue(dwellerToOutputConnection, out var isNavigableToOutput))
			{
				if (Navigation.TryQuery(output.Parent, out var queryOutput))
				{
					isNavigableToOutput = NavigationUtility.CalculateNearest(
						dweller.Transform.Position.Value,
						out _,
						queryOutput
					);
				}
				else Debug.LogError($"Unable to query {output.Parent}");
								
				navigationCache.Add(dwellerToOutputConnection, isNavigableToOutput);
			}

			return isNavigableToOutput;
		}
		#endregion
	}
}