using System;
using System.Collections.Generic;
using System.Linq;
using Lunra.Core;
using Lunra.Hothouse.Ai;
using Lunra.Hothouse.Models;
using Lunra.Satchel;
using Lunra.StyxMvp.Services;
using UnityEngine;

namespace Lunra.Hothouse.Services
{
	public class LogisticsService : BindableService<GameModel>
	{
		struct ItemCache
		{
			public Item Item;
			public Vector3 Position;
			public int Priority;
			public IInventoryModel Parent;
		}

		struct ContainerConnection : IEquatable<ContainerConnection>
		{
			public static ContainerConnection Between(long primary, long secondary) => new ContainerConnection(primary, secondary);
			
			public long Primary { get; }
			public long Secondary { get; }

			public ContainerConnection(
				long primary,
				long secondary
			)
			{
				Primary = primary;
				Secondary = secondary;
			}
			
			public override bool Equals(object obj) => obj is ContainerConnection connection && Equals(connection);

			public bool Equals(ContainerConnection other)
			{
				if (Primary == other.Primary) return Secondary == other.Secondary;
				return Primary == other.Secondary && Secondary == other.Primary;
			}

			// This code was autogenerated by Rider...
			public override int GetHashCode()
			{
				unchecked
				{
					return (Primary.GetHashCode() * 397) ^ Secondary.GetHashCode();
				}
			}

			public static bool operator ==(ContainerConnection left, ContainerConnection right) => left.Equals(right);

			public static bool operator !=(ContainerConnection left, ContainerConnection right) => !left.Equals(right);
		}

		DateTime lastNavigationCache;
		Dictionary<ContainerConnection, bool> navigationCache = new Dictionary<ContainerConnection, bool>();
		
		public LogisticsService(GameModel model) : base(model)
		{
			
		}
		
		protected override void Bind()
		{
			Model.SimulationUpdate += OnGameSimulationUpdate;
		}

		protected override void UnBind()
		{
			Model.SimulationUpdate -= OnGameSimulationUpdate;
		}

		bool hasBruk = false;
		
		#region GameModel Events
		void OnGameSimulationUpdate()
		{
			if (!hasBruk)
			{
				// Debug.Break();
				hasBruk = true;
				return;
			}

			try
			{
				switch (Model.NavigationMesh.CalculationState.Value)
				{
					case NavigationMeshModel.CalculationStates.NotInitialized:
					case NavigationMeshModel.CalculationStates.Queued:
					case NavigationMeshModel.CalculationStates.Calculating:
						return;
					case NavigationMeshModel.CalculationStates.Completed:
						break;
					default:
						Debug.LogError($"Unrecognized Calculation State: {Model.NavigationMesh.CalculationState.Value}");
						return;
				}

				if (lastNavigationCache < Model.NavigationMesh.LastUpdated.Value)
				{
					lastNavigationCache = Model.NavigationMesh.LastUpdated.Value;
					navigationCache.Clear();
				}
				
				// Do I need to calculate here??? Probably should have inventories do it when needed...
				// It becomes really hard to know what needs to be calculated when if we don't just calculate everything here
				foreach (var inventory in Model.Query.All<IInventoryModel>())
				{
					inventory.Inventory.Calculate();
				}

				var dwellers = new Dictionary<string, DwellerModel>();

				foreach (var dweller in Model.Dwellers.AllActive)
				{
					if (dweller.InventoryPromises.All.None()) dwellers.Add(dweller.Id.Value, dweller);
				}

				if (dwellers.None()) return;

				var reservationInputs = new Dictionary<long, ItemCache>();
				var reservationOutputs = new Dictionary<long, ItemCache>();

				var capacityPoolPriorities = new Dictionary<long, int>();
				
				foreach (var item in Model.Items.All(i => i[Items.Keys.Shared.Type] == Items.Values.Shared.Types.Reservation))
				{
					if (item.NoInstances) continue;

					var logisticState = item[Items.Keys.Reservation.LogisticState];

					var cache = new ItemCache
					{
						Item = item
					};

					var capacityPoolId = item[Items.Keys.Reservation.CapacityPoolId];

					if (!capacityPoolPriorities.TryGetValue(capacityPoolId, out cache.Priority))
					{
						if (Model.Items.TryGet(capacityPoolId, out var capacityPool))
						{
							cache.Priority = capacityPool[Items.Keys.CapacityPool.Priority];
						}
						else Debug.LogError($"Cannot find capacity pool [ {capacityPoolId} ]");

						capacityPoolPriorities[capacityPoolId] = cache.Priority;
					}

					if (Model.Query.TryFindFirst(m => m.Inventory.Container.Id == item.ContainerId, out cache.Parent))
					{
						cache.Position = cache.Parent.Transform.Position.Value;

						if (logisticState == Items.Values.Reservation.LogisticStates.Input) reservationInputs.Add(item.Id, cache);
						else if (logisticState == Items.Values.Reservation.LogisticStates.Output) reservationOutputs.Add(item.Id, cache);
						else Debug.LogError($"Unrecognized {Items.Keys.Reservation.LogisticState} on reservation {item}");
					}
					else Debug.LogError($"Cannot find parent of container {item.ContainerId} for item {item}");
				}

				var reservationInputsSorted = reservationInputs.Values
					.OrderBy(r => r.Priority)
					.ToList();

				while (dwellers.Any() && reservationInputsSorted.Any())
				{
					var reservationInput = reservationInputsSorted[0];
					reservationInputsSorted.RemoveAt(0);

					if (!reservationInput.Parent.Inventory.Capacities.TryGetValue(reservationInput.Item[Items.Keys.Reservation.CapacityId], out var filter))
					{
						Debug.LogError($"Cannot find filter for reservation {reservationInput.Item}");
						continue;
					}

					var reservationInputRemaining = reservationInput.Item.InstanceCount;

					var reservationOutputsSorted = reservationOutputs.Values
						.OrderBy(r => r.Priority)
						.ThenBy(r => r.Parent.DistanceTo(reservationInput.Parent))
						.ToList();

					while (0 < reservationInputRemaining && reservationOutputsSorted.Any() && dwellers.Any())
					{
						var reservationOutput = reservationOutputsSorted[0];
						reservationOutputsSorted.RemoveAt(0);

						var reservationOutputRemaining = reservationOutput.Item.InstanceCount;

						var dwellersSorted = dwellers.Values
							.OrderBy(d => d.DistanceTo(reservationOutput.Parent))
							.ToList();

						while (0 < reservationInputRemaining && 0 < reservationOutputRemaining && dwellersSorted.Any())
						{
							var dweller = dwellersSorted[0];
							dwellersSorted.RemoveAt(0);

							var dwellerToInputConnection = ContainerConnection.Between(dweller.Inventory.Container.Id, reservationInput.Parent.Inventory.Container.Id);
							if (!navigationCache.TryGetValue(dwellerToInputConnection, out var isNavigableToInput))
							{
								if (Navigation.TryQuery(reservationInput.Parent, out var queryInput))
								{
									isNavigableToInput = NavigationUtility.CalculateNearest(
										dweller.Transform.Position.Value,
										out _,
										queryInput
									);
								}
								else Debug.LogError($"Unable to query {reservationInput.Parent}");
								
								navigationCache.Add(dwellerToInputConnection, isNavigableToInput);
							}

							if (!isNavigableToInput) continue;

							var dwellerToOutputConnection = ContainerConnection.Between(dweller.Inventory.Container.Id, reservationOutput.Parent.Inventory.Container.Id);
							if (!navigationCache.TryGetValue(dwellerToOutputConnection, out var isNavigableToOutput))
							{
								if (Navigation.TryQuery(reservationOutput.Parent, out var queryOutput))
								{
									isNavigableToOutput = NavigationUtility.CalculateNearest(
										dweller.Transform.Position.Value,
										out _,
										queryOutput
									);
								}
								else Debug.LogError($"Unable to query {reservationOutput.Parent}");
								
								navigationCache.Add(dwellerToOutputConnection, isNavigableToOutput);
							}
							
							if (!isNavigableToOutput) continue;

							var items = reservationOutput.Parent.Inventory.Container
								.All(i => i[Items.Keys.Resource.CapacityPoolId] == reservationOutput.Item[Items.Keys.Reservation.CapacityPoolId])
								.ToList();

							foreach (var (item, stack) in items)
							{
								if (filter.Validate(item))
								{
									reservationInputRemaining--;
									reservationOutputRemaining--;

									var output = new InventoryPromiseComponent.TransferInfo
									{
										Container = reservationOutput.Parent.Inventory.Container,
										Capacity = Model.Items.First(reservationOutput.Item[Items.Keys.Reservation.CapacityId]),

										// It's okay if the source doesn't have a capacity pool.
										CapacityPool = Model.Items.FirstOrDefault(reservationOutput.Item[Items.Keys.Reservation.CapacityPoolId]),

										Reservation = reservationOutput.Item
									};

									var input = new InventoryPromiseComponent.TransferInfo
									{
										Container = reservationInput.Parent.Inventory.Container,
										Capacity = Model.Items.First(reservationInput.Item[Items.Keys.Reservation.CapacityId]),

										// This capacity pool is required.
										CapacityPool = Model.Items.First(reservationInput.Item[Items.Keys.Reservation.CapacityPoolId]),

										Reservation = reservationInput.Item,
									};

									var isReservationInputSatisfied = dweller.InventoryPromises.Transfer(
										item,
										output,
										input
									);

									dwellers.Remove(dweller.Id.Value);

									if (isReservationInputSatisfied) break;
								}
							}
						}
					}
				}
			}
			catch (Exception e) { Debug.LogException(e); }
		}
		#endregion
	}
}